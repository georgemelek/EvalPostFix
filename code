#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
using namespace std;

class PrecondViolatedExcept: public logic_error {
    public:
        PrecondViolatedExcept(const string& message = "");
};

template<class T>
class dynArrStack {
    private:
        static const int deCap = 30;
        int top;
        T* items; // array in the dynamic memory storage
    public:
        dynArrStack() : top(-1) { items = new T[deCap]; }
        dynArrStack(const dynArrStack<T>& rhs);
        ~dynArrStack() { delete [] items; top = -1; }
        dynArrStack<T>& operator=( const dynArrStack<T>& rhs ){ //overloaded assignment operator
            top = rhs.top;
            delete[] items;
            items = new T[deCap];
            for(int i=0; i <= top; i++) {
                items[i] = rhs.items[i];
            }
            return *this;
        }
        bool isEmpty() const;
        bool push(const T& nEntry);
        bool pop();
        T peek() const throw(PrecondViolatedExcept);
        T peek2() const throw(PrecondViolatedExcept);
        int size() const { return top + 1; }
        //T evalPostFix(string expression);
};

template <class T>
T evalPostFix(dynArrStack<T>& stack, string& str);

int main()
{
    dynArrStack<double> test;
    string str = "25.4 3.0 10.2 * + 9.5 - q";

    evalPostFix(test, str);
    try{
        cout << test.peek() << endl;
    } catch (logic_error ex) {
        cout << ex.what() << endl;
    }
    //cout << test.peek();
    return 0;
}


PrecondViolatedExcept::PrecondViolatedExcept(const string& message): logic_error("Precondition Violated Exception: " + message) {}

//Copy Constructor
template<class T>
dynArrStack<T>::dynArrStack(const dynArrStack<T>& rhs){
    top = rhs.top;
    items = new T[deCap];
    for(int i=0; i <= top; i++) {
        items[i] = rhs.items[i];
    }
}

//Checks if there are no elements
template<class T>
bool dynArrStack<T>::isEmpty() const{
    return top < 0;
}

//Adds an element to the top of the stack
template<class T>
bool dynArrStack<T>::push(const T& nEntry){
    bool result = false;
    if(top+1<deCap){
        top++;
        items[top] = nEntry;
        result = true;
    }
    return result;
}

//Pops out an element from the top
template<class T>
bool dynArrStack<T>::pop(){
    bool result = false;
    if (-1<top-1){
        top--;
        result = true;
    }
    return result;
}

//Only looks at the the top element and returns its value
template<class T>
T dynArrStack<T>::peek() const throw(PrecondViolatedExcept){
    if(top+1<1){
        throw PrecondViolatedExcept("peek() called with empty stack");
    }
    return items[top];
}

//Looks at the second-to-top element and returns its value
template<class T>
T dynArrStack<T>::peek2() const throw(PrecondViolatedExcept){
    if(top+1<2){
        throw PrecondViolatedExcept("peek2() called with less than 2 elements");
    }
    return items[top-1];
}

template <class T>
T evalPostFix(dynArrStack<T>& stack, string& str){
    stringstream expression{str};
    string elem;
    while(expression >> elem){
        if(elem == "+"){
            double topNum = stack.peek();
            double bottomNum = stack.peek2();
            stack.pop();
            stack.pop();
            stack.push(topNum+bottomNum);
        }
        else if(elem == "*"){
            double topNum = stack.peek();
            double bottomNum = stack.peek2();
            stack.pop();
            stack.pop();
            stack.push(topNum*bottomNum);
        }
        else if(elem == "-"){
            double topNum = stack.peek();
            double bottomNum = stack.peek2();
            stack.pop();
            stack.pop();
            stack.push(bottomNum-topNum);
        }
        else if(elem == "/"){
            double topNum = stack.peek();
            double bottomNum = stack.peek2();
            stack.pop();
            stack.pop();
            stack.push(bottomNum/topNum);
        }
        else if(elem == "q"){
            break;
        }
        else{
            stringstream str2Int(elem); 
            float x = 0; 
            str2Int >> x; 
            stack.push(x);
        }
        
    }
    return stack.peek();
}
